; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature
; REQUIRES: asserts
; RUN: opt -passes=instcombine -S %s -o - -debug-only=instcombine,instsimplify
; RUN: opt -passes=instcombine -S %s -o - | FileCheck %s -check-prefixes CHECK,INSTCOMBINE
; RUN: opt -passes=instsimplify -S %s -o - | FileCheck %s -check-prefixes CHECK,INSTSIMPLIFY
target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200"
target triple = "cheri-unknown-freebsd"

declare i64 @llvm.cheri.cap.diff.i64(ptr addrspace(200), ptr addrspace(200)) addrspace(200)
declare ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200), i64) addrspace(200)
declare ptr addrspace(200) @llvm.cheri.cap.bounds.set.exact.i64(ptr addrspace(200), i64) addrspace(200)
declare ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200), i64) addrspace(200)
declare i8 addrspace(200)* @llvm.cheri.cap.perms.and.i64(i8 addrspace(200)*, i64)


declare void @use(ptr addrspace(200)) addrspace(200)
declare void @use32(ptr addrspace(200)) addrspace(200)


define ptr addrspace(200) @setbounds_idempotent(ptr addrspace(200) %ptr, i64 %size) addrspace(200) {
; Same argument so we can combine
; CHECK-LABEL: define {{[^@]+}}@setbounds_idempotent
; CHECK-SAME: (ptr addrspace(200) [[PTR:%.*]], i64 [[SIZE:%.*]]) addrspace(200) {
; CHECK-NEXT:    [[FIRST:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[PTR]], i64 [[SIZE]])
; CHECK-NEXT:    ret ptr addrspace(200) [[FIRST]]
;
  %first = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %ptr, i64 %size)
  %second = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %first, i64 %size)
  %third = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %second, i64 %size)
  ret ptr addrspace(200) %third
}

define ptr addrspace(200) @setbounds_idempotent_ignore_bitcasts(ptr addrspace(200) %ptr, i64 %size) addrspace(200) {
; Same argument so we can combine
; CHECK-LABEL: define {{[^@]+}}@setbounds_idempotent_ignore_bitcasts
; CHECK-SAME: (ptr addrspace(200) [[PTR:%.*]], i64 [[SIZE:%.*]]) addrspace(200) {
; CHECK-NEXT:    [[FIRST:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[PTR]], i64 [[SIZE]])
; CHECK-NEXT:    call void @use32(ptr addrspace(200) [[FIRST]])
; CHECK-NEXT:    ret ptr addrspace(200) [[FIRST]]
;
  %first = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %ptr, i64 %size)
  %tmp = bitcast ptr addrspace(200) %first to ptr addrspace(200)
  call void @use32(ptr addrspace(200) %tmp)
  %tmp2 = bitcast ptr addrspace(200) %tmp to ptr addrspace(200)
  %second = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %tmp2, i64 %size)
  %third = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %second, i64 %size)
  ret ptr addrspace(200) %third
}

define ptr addrspace(200) @setbounds_different_args_1(ptr addrspace(200) %ptr, i64 %size) addrspace(200) {
; Can't combine here:
; CHECK-LABEL: define {{[^@]+}}@setbounds_different_args_1
; CHECK-SAME: (ptr addrspace(200) [[PTR:%.*]], i64 [[SIZE:%.*]]) addrspace(200) {
; CHECK-NEXT:    [[FIRST:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[PTR]], i64 [[SIZE]])
; CHECK-NEXT:    [[SECOND:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[FIRST]], i64 1)
; CHECK-NEXT:    [[THIRD:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[SECOND]], i64 [[SIZE]])
; CHECK-NEXT:    ret ptr addrspace(200) [[THIRD]]
;
  %first = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %ptr, i64 %size)
  %second = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %first, i64 1)
  %third = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %second, i64 %size)
  ret ptr addrspace(200) %third
}

; If one of the instructions is a setbounds exact we have to use the exact version:
define ptr addrspace(200) @setbounds_idempotent_exact1(ptr addrspace(200) %ptr, i64 %size) addrspace(200) {
; Must use exact version when combining
; CHECK-LABEL: define {{[^@]+}}@setbounds_idempotent_exact1
; CHECK-SAME: (ptr addrspace(200) [[PTR:%.*]], i64 [[SIZE:%.*]]) addrspace(200) {
; CHECK-NEXT:    [[FIRST:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.exact.i64(ptr addrspace(200) [[PTR]], i64 [[SIZE]])
; CHECK-NEXT:    ret ptr addrspace(200) [[FIRST]]
;
  %first = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.exact.i64(ptr addrspace(200) %ptr, i64 %size)
  %second = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %first, i64 %size)
  %third = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %second, i64 %size)
  ret ptr addrspace(200) %third
}

define ptr addrspace(200) @setbounds_idempotent_exact2(ptr addrspace(200) %ptr, i64 %size) addrspace(200) {
; Must use exact version when combining
; Can't upgrade inexact to exact when running instsimplify
; INSTCOMBINE-LABEL: define {{[^@]+}}@setbounds_idempotent_exact2
; INSTCOMBINE-SAME: (ptr addrspace(200) [[PTR:%.*]], i64 [[SIZE:%.*]]) addrspace(200) {
; INSTCOMBINE-NEXT:    [[SECOND:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.exact.i64(ptr addrspace(200) [[PTR]], i64 [[SIZE]])
; INSTCOMBINE-NEXT:    ret ptr addrspace(200) [[SECOND]]
;
; INSTSIMPLIFY-LABEL: define {{[^@]+}}@setbounds_idempotent_exact2
; INSTSIMPLIFY-SAME: (ptr addrspace(200) [[PTR:%.*]], i64 [[SIZE:%.*]]) addrspace(200) {
; INSTSIMPLIFY-NEXT:    [[FIRST:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[PTR]], i64 [[SIZE]])
; INSTSIMPLIFY-NEXT:    [[SECOND:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.exact.i64(ptr addrspace(200) [[FIRST]], i64 [[SIZE]])
; INSTSIMPLIFY-NEXT:    ret ptr addrspace(200) [[SECOND]]
;
  %first = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %ptr, i64 %size)
  %second = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.exact.i64(ptr addrspace(200) %first, i64 %size)
  %third = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %second, i64 %size)
  ret ptr addrspace(200) %third
}

define ptr addrspace(200) @setbounds_idempotent_exact3(ptr addrspace(200) %ptr, i64 %size) addrspace(200) {
; Must use exact version when combining
; Can't upgrade inexact to exact when running instsimplify
; INSTCOMBINE-LABEL: define {{[^@]+}}@setbounds_idempotent_exact3
; INSTCOMBINE-SAME: (ptr addrspace(200) [[PTR:%.*]], i64 [[SIZE:%.*]]) addrspace(200) {
; INSTCOMBINE-NEXT:    [[THIRD:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.exact.i64(ptr addrspace(200) [[PTR]], i64 [[SIZE]])
; INSTCOMBINE-NEXT:    ret ptr addrspace(200) [[THIRD]]
;
; INSTSIMPLIFY-LABEL: define {{[^@]+}}@setbounds_idempotent_exact3
; INSTSIMPLIFY-SAME: (ptr addrspace(200) [[PTR:%.*]], i64 [[SIZE:%.*]]) addrspace(200) {
; INSTSIMPLIFY-NEXT:    [[FIRST:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[PTR]], i64 [[SIZE]])
; INSTSIMPLIFY-NEXT:    [[THIRD:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.exact.i64(ptr addrspace(200) [[FIRST]], i64 [[SIZE]])
; INSTSIMPLIFY-NEXT:    ret ptr addrspace(200) [[THIRD]]
;
  %first = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %ptr, i64 %size)
  %second = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %first, i64 %size)
  %third = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.exact.i64(ptr addrspace(200) %second, i64 %size)
  ret ptr addrspace(200) %third
}

define ptr addrspace(200) @setbounds_idempotent_exact4(ptr addrspace(200) %ptr, i64 %size) addrspace(200) {
; Must use exact version when combining
; CHECK-LABEL: define {{[^@]+}}@setbounds_idempotent_exact4
; CHECK-SAME: (ptr addrspace(200) [[PTR:%.*]], i64 [[SIZE:%.*]]) addrspace(200) {
; CHECK-NEXT:    [[FIRST:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.exact.i64(ptr addrspace(200) [[PTR]], i64 [[SIZE]])
; CHECK-NEXT:    ret ptr addrspace(200) [[FIRST]]
;
  %first = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.exact.i64(ptr addrspace(200) %ptr, i64 %size)
  %second = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.exact.i64(ptr addrspace(200) %first, i64 %size)
  %third = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.exact.i64(ptr addrspace(200) %second, i64 %size)
  ret ptr addrspace(200) %third
}

define ptr addrspace(200) @no_remove_exact(ptr addrspace(200) %ptr, i64 %size, i1 %maybe_use) addrspace(200) {
; Can't just replace the inexact version with exact if the exact one might not be used (this could trigger a trap)
; INSTCOMBINE-LABEL: define {{[^@]+}}@no_remove_exact
; INSTCOMBINE-SAME: (ptr addrspace(200) [[PTR:%.*]], i64 [[SIZE:%.*]], i1 [[MAYBE_USE:%.*]]) addrspace(200) {
; INSTCOMBINE-NEXT:    br i1 [[MAYBE_USE]], label [[USE:%.*]], label [[NO_USE:%.*]]
; INSTCOMBINE:       use:
; INSTCOMBINE-NEXT:    [[FIRST:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[PTR]], i64 [[SIZE]])
; INSTCOMBINE-NEXT:    call void @use(ptr addrspace(200) [[FIRST]])
; INSTCOMBINE-NEXT:    br label [[END:%.*]]
; INSTCOMBINE:       no_use:
; INSTCOMBINE-NEXT:    [[THIRD:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.exact.i64(ptr addrspace(200) [[PTR]], i64 [[SIZE]])
; INSTCOMBINE-NEXT:    call void @use(ptr addrspace(200) [[THIRD]])
; INSTCOMBINE-NEXT:    br label [[END]]
; INSTCOMBINE:       end:
; INSTCOMBINE-NEXT:    ret ptr addrspace(200) null
;
; INSTSIMPLIFY-LABEL: define {{[^@]+}}@no_remove_exact
; INSTSIMPLIFY-SAME: (ptr addrspace(200) [[PTR:%.*]], i64 [[SIZE:%.*]], i1 [[MAYBE_USE:%.*]]) addrspace(200) {
; INSTSIMPLIFY-NEXT:    [[FIRST:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[PTR]], i64 [[SIZE]])
; INSTSIMPLIFY-NEXT:    br i1 [[MAYBE_USE]], label [[USE:%.*]], label [[NO_USE:%.*]]
; INSTSIMPLIFY:       use:
; INSTSIMPLIFY-NEXT:    call void @use(ptr addrspace(200) [[FIRST]])
; INSTSIMPLIFY-NEXT:    br label [[END:%.*]]
; INSTSIMPLIFY:       no_use:
; INSTSIMPLIFY-NEXT:    [[THIRD:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.exact.i64(ptr addrspace(200) [[FIRST]], i64 [[SIZE]])
; INSTSIMPLIFY-NEXT:    call void @use(ptr addrspace(200) [[THIRD]])
; INSTSIMPLIFY-NEXT:    br label [[END]]
; INSTSIMPLIFY:       end:
; INSTSIMPLIFY-NEXT:    ret ptr addrspace(200) null
;
  %first = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %ptr, i64 %size)
  br i1 %maybe_use, label %use, label %no_use

use:                                              ; preds = %0
  call void @use(ptr addrspace(200) %first)
  br label %end

no_use:                                           ; preds = %0
  %second = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %first, i64 %size)
  %third = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.exact.i64(ptr addrspace(200) %second, i64 %size)
  call void @use(ptr addrspace(200) %third)
  br label %end

end:                                              ; preds = %no_use, %use
  ret ptr addrspace(200) null
}

define ptr addrspace(200) @permsand_idempotent_const(ptr addrspace(200) %ptr) addrspace(200) {
; INSTCOMBINE-LABEL: define {{[^@]+}}@permsand_idempotent_const
; INSTCOMBINE-SAME: (ptr addrspace(200) [[PTR:%.*]]) addrspace(200) {
; INSTCOMBINE-NEXT:    [[SECOND:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.perms.and.i64(ptr addrspace(200) [[PTR]], i64 6)
; INSTCOMBINE-NEXT:    ret ptr addrspace(200) [[SECOND]]
;
; INSTSIMPLIFY-LABEL: define {{[^@]+}}@permsand_idempotent_const
; INSTSIMPLIFY-SAME: (ptr addrspace(200) [[PTR:%.*]]) addrspace(200) {
; INSTSIMPLIFY-NEXT:    [[FIRST:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.perms.and.i64(ptr addrspace(200) [[PTR]], i64 14)
; INSTSIMPLIFY-NEXT:    [[SECOND:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.perms.and.i64(ptr addrspace(200) [[FIRST]], i64 7)
; INSTSIMPLIFY-NEXT:    ret ptr addrspace(200) [[SECOND]]
;
  %first = call ptr addrspace(200) @llvm.cheri.cap.perms.and.i64(ptr addrspace(200) %ptr, i64 14)
  %second = call ptr addrspace(200) @llvm.cheri.cap.perms.and.i64(ptr addrspace(200) %first, i64 7)
  ret ptr addrspace(200) %second
}

define ptr addrspace(200) @permsand_idempotent(ptr addrspace(200) %ptr, i64 %size) addrspace(200) {
; CHECK-LABEL: define {{[^@]+}}@permsand_idempotent
; CHECK-SAME: (ptr addrspace(200) [[PTR:%.*]], i64 [[SIZE:%.*]]) addrspace(200) {
; CHECK-NEXT:    [[FIRST:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.perms.and.i64(ptr addrspace(200) [[PTR]], i64 [[SIZE]])
; CHECK-NEXT:    ret ptr addrspace(200) [[FIRST]]
;
  %first = call ptr addrspace(200) @llvm.cheri.cap.perms.and.i64(ptr addrspace(200) %ptr, i64 %size)
  %second = call ptr addrspace(200) @llvm.cheri.cap.perms.and.i64(ptr addrspace(200) %first, i64 %size)
  %third = call ptr addrspace(200) @llvm.cheri.cap.perms.and.i64(ptr addrspace(200) %second, i64 %size)
  ret ptr addrspace(200) %third
}
